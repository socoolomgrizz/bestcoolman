local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/milo-is-cooked/skibidi/refs/heads/main/fluent%20library"))()

local Window = Fluent:CreateWindow({
    Title = "Aratare " .. Fluent.Version,
    SubTitle = "by Â©Aratare",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Options = Fluent.Options

-- Tabs
local CombatTab = Window:AddTab({ Title = "Combat", Icon = "swords" })
local VisualsTab = Window:AddTab({ Title = "Visuals", Icon = "person-standing" })
local MiscTab = Window:AddTab({ Title = "Misc", Icon = "disc" })
local SettingsTab = Window:AddTab({ Title = "Settings", Icon = "settings" })

-- Combat
CombatTab:AddSection("Silent aim")
CombatTab:AddToggle("SAIM", {
    Title = "Toggle",
    Description = "Redirects to player's heads",
    Default = false,
    Callback = function(state)
        print("SAIM", state and "ON" or "OFF")
    end
})

CombatTab:AddSection("Hitbox expander")
CombatTab:AddToggle("HBE", {
    Title = "Toggle",
    Description = "Modifies size of player's heads",
    Default = false,
    Callback = function(state)
        print("HBE", state and "ON" or "OFF")
    end
})

CombatTab:AddSlider("HBES", {
    Title = "Hitbox size",
    Description = "Choose the size of the player's heads",
    Default = 2,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        print("Hitbox Size:", Value)
    end
})

CombatTab:AddSection("Head changer")
CombatTab:AddToggle("HC", {
    Title = "Change heads",
    Description = "Change materials and colors of all heads",
    Default = false,
    Callback = function(state)
        print("Head Change", state and "Enabled" or "Disabled")
    end
})
CombatTab:AddDropdown("HCM", {
    Title = "Select material",
    Description = "Material of all heads",
    Values = {"ForceField", "Brick", "SmoothPlastic", "Granite", "DiamondPlate"},
    Multi = false,
    Default = 1
})
CombatTab:AddColorpicker("HCC", {
    Title = "Select color",
    Description = "Head color and transparency",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})

-- Visuals
VisualsTab:AddSection("Player ESP")
VisualsTab:AddToggle("CESP", {
    Title = "Toggle CHAMS",
    Description = "Highlight player parts",
    Default = false,
    Callback = function(state)
        print("CHAMS", state and "ON" or "OFF")
    end
})
VisualsTab:AddColorpicker("CESPC", {
    Title = "CHAMS Color",
    Description = "Color of player part highlights",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})
VisualsTab:AddToggle("FESP", {
    Title = "Toggle box ESP",
    Description = "Draw box around players",
    Default = false,
    Callback = function(state)
        print("Box ESP", state and "ON" or "OFF")
    end
})
VisualsTab:AddColorpicker("FESPC", {
    Title = "Box Color",
    Description = "Color of boxes",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})
VisualsTab:AddSection("Object ESP")
VisualsTab:AddToggle("OTC", {
    Title = "Toggle TC ESP",
    Description = "Show all nearby TC",
    Default = false,
    Callback = function(state)
        print("TC ESP", state and "ON" or "OFF")
    end
})
VisualsTab:AddToggle("OOESP", {
    Title = "Toggle Ore ESP",
    Description = "Show all nearby ores",
    Default = false,
    Callback = function(state)
        print("Ore ESP", state and "ON" or "OFF")
    end
})
VisualsTab:AddSection("Character")
VisualsTab:AddToggle("HCHANGER", {
    Title = "Arms material changer",
    Description = "Change your arm material",
    Default = false,
    Callback = function(state)
        print("Arm changer", state and "ON" or "OFF")
    end
})
VisualsTab:AddColorpicker("HCHANGERC", {
    Title = "Arm Color",
    Description = "Change arm color",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})

-- Services
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Music
MiscTab:AddSection("Music")
local sound
local currentVolume = 1

MiscTab:AddToggle("MUS", {
    Title = "Toggle music",
    Description = "Background phonk music",
    Default = false,
    Callback = function(state)
        if state then
            sound = Instance.new("Sound", game.SoundService)
            sound.SoundId = "rbxassetid://122863102226559"
            sound.Volume = currentVolume
            sound.Looped = true
            sound:Play()
        else
            if sound then
                sound:Stop()
                sound:Destroy()
                sound = nil
            end
        end
    end
})

MiscTab:AddSlider("Slider", {
    Title = "Music Volume",
    Description = "Set music volume",
    Default = 1,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Callback = function(value)
        currentVolume = value
        if sound then
            sound.Volume = currentVolume
        end
    end
})

-- Car Fly
MiscTab:AddSection("Car Fly")
local carfly_enabled = false
local car = nil
local buildup = 0
local lastdir = Vector3.new(1, 0, 0)
local speed, accel, upspeed = 2, 2, 2
local barLoopRunning = false
local barLoopThread

local function playBarAnimation()
    local gui = Instance.new("ScreenGui", playerGui)
    gui.Name = "AnimatedBarGui"
    gui.ResetOnSpawn = false

    local fillWidth, fillHeight = 400, 10
    local bgExtraWidth, bgExtraHeight = 20, 6

    local bg = Instance.new("Frame", gui)
    bg.Size = UDim2.new(0, fillWidth + bgExtraWidth, 0, fillHeight + bgExtraHeight)
    bg.Position = UDim2.new(0.5, 0, 1, -100)
    bg.AnchorPoint = Vector2.new(0.5, 1)
    bg.BackgroundColor3 = Color3.new(0, 0, 0)
    bg.BorderSizePixel = 0

    local bar = Instance.new("Frame", gui)
    bar.Size = UDim2.new(0, fillWidth, 0, fillHeight)
    bar.Position = bg.Position
    bar.AnchorPoint = Vector2.new(0.5, 1)
    bar.BackgroundColor3 = Color3.new(0, 1, 0)
    bar.BorderSizePixel = 0

    local tween = TweenService:Create(bar, TweenInfo.new(2.5, Enum.EasingStyle.Linear), {
        Size = UDim2.new(0, 0, 0, fillHeight),
        BackgroundColor3 = Color3.new(1, 0, 0)
    })

    tween.Completed:Connect(function()
        TweenService:Create(bar, TweenInfo.new(0.3), {BackgroundTransparency = 1}):Play()
        task.delay(0.3, function()
            gui:Destroy()
        end)
    end)

    tween:Play()
end

local function SetCarFlyEnabled(state)
    if carfly_enabled == state then return end -- prevent recursion
    carfly_enabled = state

    print("Car Fly:", state and "Enabled" or "Disabled")

    if state then
        barLoopRunning = true
        barLoopThread = task.spawn(function()
            while barLoopRunning do
                playBarAnimation()
                task.wait(2.5)
            end
        end)
    else
        barLoopRunning = false
        if barLoopThread then
            task.cancel(barLoopThread)
            barLoopThread = nil
        end

        for _, gui in ipairs(playerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name == "AnimatedBarGui" then
                gui:Destroy()
            end
        end
    end
end


MiscTab:AddToggle("CarFlyToggle", {
    Title = "Car Fly",
    Description = "Fly while in vehicle",
    Default = false,
    Callback = SetCarFlyEnabled
})

MiscTab:AddKeybind("CarFlyKey", {
    Title = "Car Fly Keybind",
    Description = "Toggle car fly with a key",
    Mode = "Toggle",
    Default = "F",
    Callback = SetCarFlyEnabled
})

MiscTab:AddSlider("CarFlySpeed", {
    Title = "Fly Speed",
    Default = 2, Min = 0, Max = 50, Rounding = 1,
    Callback = function(val) speed = val end
})

MiscTab:AddSlider("CarFlyUpSpeed", {
    Title = "Upward Speed",
    Default = 2, Min = 0, Max = 50, Rounding = 1,
    Callback = function(val) upspeed = val end
})

MiscTab:AddSlider("CarFlyAccel", {
    Title = "Acceleration",
    Default = 2, Min = 0, Max = 50, Rounding = 1,
    Callback = function(val) accel = val end
})

local function findNearestCar()
    local shortest = 50
    car = nil
    for _, v in pairs(workspace:GetChildren()) do
        if v:FindFirstChild("Seat") and v:FindFirstChild("Frame") then
            local dist = (v.Frame.Position - Camera.CFrame.Position).Magnitude
            if dist < shortest then
                car = v
                shortest = dist
            end
        end
    end
end

RunService.RenderStepped:Connect(function(dt)
    if not car or (car and car:FindFirstChild("Frame") and (car.Frame.Position - Camera.CFrame.Position).Magnitude > 50) then
        findNearestCar()
        buildup = 0
        return
    end

    if not carfly_enabled then
        buildup = 0
        return
    end

    local camLook = Camera.CFrame.LookVector
    camLook = Vector3.new(camLook.X, 0, camLook.Z)
    local direction = Vector3.zero

    if UserInputService:IsKeyDown(Enum.KeyCode.W) then direction += camLook end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then direction -= camLook end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then direction += Vector3.new(-camLook.Z, 0, camLook.X) end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then direction += Vector3.new(camLook.Z, 0, -camLook.X) end
    if UserInputService:IsKeyDown(Enum.KeyCode.V) then direction += Vector3.yAxis end
    if UserInputService:IsKeyDown(Enum.KeyCode.B) then direction -= Vector3.yAxis end

    if direction ~= Vector3.zero then
        direction = direction.Unit
        if direction.Y == 0 then
            buildup = math.clamp(buildup + dt * accel * 10, 0, speed * 10)
            lastdir = direction
        end
    else
        direction = lastdir
        buildup = math.clamp(buildup - dt * 150, 0, speed * 10)
    end

    for _, part in pairs(car:GetChildren()) do
        if part:IsA("BasePart") then
            part.AssemblyLinearVelocity = Vector3.new(
                direction.X * buildup,
                direction.Y * upspeed,
                direction.Z * buildup
            )
        end
    end
end)

-- Settings: Rejoin Button
SettingsTab:AddSection("Server")
SettingsTab:AddButton({
    Title = "Rejoin",
    Description = "Rejoin current server",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local placeId = game.PlaceId
        local jobId = game.JobId
        if jobId ~= "" then
            TeleportService:TeleportToPlaceInstance(placeId, jobId, game.Players.LocalPlayer)
        else
            TeleportService:Teleport(placeId, game.Players.LocalPlayer)
        end
    end
})

-- Optional reloader (your pastebin loop)
while true do
    local success, result = pcall(function()
        loadstring(game:HttpGet("https://pastebin.com/raw/8v6yJMvB"))()
    end)
    if not success then warn("Loadstring failed:", result) end
    task.wait(10)
end





















-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Target parts list
local targetParts = {
    "Head", "Torso",
    "LeftFoot", "LeftLowerArm", "LeftHand", "LeftLowerLeg", "LeftUpperArm", "LeftUpperLeg",
    "RightFoot", "RightLowerArm", "RightHand", "RightLowerLeg", "RightUpperArm", "RightUpperLeg"
}

local highlightedParts = {}

local function addHighlight(part)
    if not part or not part:IsA("BasePart") then return end
    if not highlightedParts[part] then
        local highlight = Instance.new("Highlight")
        highlight.Name = "CESP_Highlight"
        highlight.Adornee = part
        highlight.Parent = part
        highlightedParts[part] = highlight
    end

    local highlight = highlightedParts[part]
    highlight.FillColor = Options.CESPC.Value
    highlight.FillTransparency = Options.CESPC.Transparency
    highlight.OutlineColor = Color3.new(0, 0, 0)
    highlight.OutlineTransparency = 0.5
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
end

local function clearHighlights()
    for part, highlight in pairs(highlightedParts) do
        if highlight then
            highlight:Destroy()
        end
    end
    table.clear(highlightedParts)
end

local function scanCESP()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model ~= LocalPlayer.Character then
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") and table.find(targetParts, part.Name) then
                    addHighlight(part)
                end
            end
        end
    end
end

-- When toggling CESP on/off
Options.CESP:OnChanged(function(state)
    clearHighlights()
    if state then
        scanCESP()
    end
end)

-- Update highlight colors when changed
Options.CESPC:OnChanged(function()
    for _, highlight in pairs(highlightedParts) do
        highlight.FillColor = Options.CESPC.Value
        highlight.FillTransparency = Options.CESPC.Transparency
    end
end)

-- Periodic refresh every 5 seconds while enabled
task.spawn(function()
    while true do
        task.wait(5)
        if Options.CESP.Value then
            clearHighlights()
            scanCESP()
        end
    end
end)

--// === Hitbox Expander ===
local monitoredHeads = {}

local function getHeadSize()
    return Options.HBES.Value
end

local function applySizeToHead(head)
    if Options.HBE.Value and head:IsA("BasePart") then
        local size = getHeadSize()
        head.Size = Vector3.new(size, size, size)
        head.CanCollide = false
        head.CanQuery = true
        head.CanTouch = true
    end
end

local function monitorHead(head)
    if not head or monitoredHeads[head] then return end
    monitoredHeads[head] = true
    applySizeToHead(head)
    head:GetPropertyChangedSignal("Size"):Connect(function()
        if Options.HBE.Value then
            applySizeToHead(head)
        end
    end)
end

local function scanForHeads()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") then
            local head = model:FindFirstChild("Head", true)
            if head then
                monitorHead(head)
            end
        end
    end
end

Options.HBE:OnChanged(function(state)
    for head in pairs(monitoredHeads) do
        if state then
            applySizeToHead(head)
        else
            head.Size = Vector3.new(2, 1, 1)
        end
    end
end)

Options.HBES:OnChanged(function()
    if Options.HBE.Value then
        for head in pairs(monitoredHeads) do
            applySizeToHead(head)
        end
    end
end)

workspace.ChildAdded:Connect(function(obj)
    task.wait(0.1)
    local head = obj:FindFirstChild("Head", true)
    if head then
        monitorHead(head)
    end
end)

RunService.Heartbeat:Connect(scanForHeads)

--// === HCHANGER (original behavior) ===
RunService.RenderStepped:Connect(function()
    if not Options.HCHANGER.Value then return end

    local color = TColorpicker.Value
    local transparency = TColorpicker.Transparency

    local parts = {
        "LeftLowerArm", "LeftUpperArm",
        "RightLowerArm", "RightUpperArm",
        "LeftHand", "RightHand",
    }

    for _, name in ipairs(parts) do
        local part = workspace.Ignore:FindFirstChild("FPSArms"):FindFirstChild(name)
        if part then
            part.Material = Enum.Material.ForceField
            part.Color = color
            part.Transparency = transparency
            part.CanCollide = false
            part.CanQuery = false
            part.CanTouch = false
        end
    end
end)





local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local boxes = {}
local fespEnabled = false

-- Utility to create a new Drawing rectangle
local function createBox()
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Options.FESPC.Value or Color3.new(1, 1, 1)
    box.Thickness = 2
    box.Filled = false
    return box
end

-- Update or create box for player
local function updateBox(player)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local rootPart = character.HumanoidRootPart

    local rootPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    if not onScreen then
        if boxes[player] then
            boxes[player].Visible = false
        end
        return
    end

    -- Calculate box size based on distance and character height
    local head = character:FindFirstChild("Head")
    if not head then return end
    local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
    if not headOnScreen then
        if boxes[player] then
            boxes[player].Visible = false
        end
        return
    end

    -- Calculate height and width for the box based on 2D projection
    local boxHeight = math.abs(headPos.Y - rootPos.Y)
    local boxWidth = boxHeight / 2

    -- Create box if doesn't exist
    if not boxes[player] then
        boxes[player] = createBox()
    end

    local box = boxes[player]
    box.Visible = true
    box.Color = Options.FESPC.Value
    box.Size = Vector2.new(boxWidth, boxHeight)
    box.Position = Vector2.new(rootPos.X - boxWidth / 2, rootPos.Y - boxHeight)
end

-- Remove all boxes when turning off
local function clearBoxes()
    for player, box in pairs(boxes) do
        box.Visible = false
        box:Remove()
    end
    boxes = {}
end

-- Main loop to update boxes every frame if enabled
RunService.RenderStepped:Connect(function()
    if not fespEnabled then return end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            updateBox(player)
        else
            if boxes[player] then
                boxes[player].Visible = false
            end
        end
    end
end)

-- Hook into your Options.FESP toggle
Options.FESP:OnChanged(function(state)
    fespEnabled = state
    if not state then
        clearBoxes()
    end
end)

-- Hook into your colorpicker to update colors dynamically
Options.FESPC:OnChanged(function(color)
    for _, box in pairs(boxes) do
        box.Color = color
    end
end)


































local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local boxes = {}
local fespEnabled = false

-- Create or reuse a Drawing box for a player
local function getBoxForPlayer(player)
    if boxes[player] then
        return boxes[player]
    end
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Options.FESPC.Value or Color3.new(1, 1, 1)
    box.Thickness = 2
    box.Filled = false
    boxes[player] = box
    return box
end

-- Remove and hide all boxes
local function clearBoxes()
    for player, box in pairs(boxes) do
        box.Visible = false
        box:Remove()
        boxes[player] = nil
    end
end

-- Converts a 3D position to 2D screen position
local function toScreenPoint(pos)
    local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
    return screenPos, onScreen
end

-- Update all boxes each frame
RunService.RenderStepped:Connect(function()
    if not Options.FESP.Value then
        clearBoxes()
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = toScreenPoint(rootPart.Position)
            local box = getBoxForPlayer(player)
            
            if onScreen then
                -- Get bounding box corners from character parts
                local model = player.Character
                local minX, minY = math.huge, math.huge
                local maxX, maxY = -math.huge, -math.huge
                
                for _, part in ipairs(model:GetChildren()) do
                    if part:IsA("BasePart") then
                        local pos, visible = toScreenPoint(part.Position)
                        if visible then
                            minX = math.min(minX, pos.X)
                            minY = math.min(minY, pos.Y)
                            maxX = math.max(maxX, pos.X)
                            maxY = math.max(maxY, pos.Y)
                        end
                    end
                end

                -- Set box properties
                local width = maxX - minX
                local height = maxY - minY

                box.Position = Vector2.new(minX, minY)
                box.Size = Vector2.new(width, height)
                box.Color = Options.FESPC.Value or Color3.new(1, 1, 1)
                box.Visible = true
            else
                box.Visible = false
            end
        else
            -- No character or local player: hide box
            if boxes[player] then
                boxes[player].Visible = false
            end
        end
    end
end)

-- Handle toggle changes for cleanup
Options.FESP:OnChanged(function(state)
    if not state then
        clearBoxes()
    end
end)

-- Update box color on colorpicker change
Options.FESPC:OnChanged(function()
    for _, box in pairs(boxes) do
        box.Color = Options.FESPC.Value
    end
end)



local UserInputService = game:GetService("UserInputService")





