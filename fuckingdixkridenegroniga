local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Aratare " .. Fluent.Version,
    SubTitle = "by Â©Aratare",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Options = Fluent.Options

-- Create all tabs once
local CombatTab = Window:AddTab({ Title = "Combat", Icon = "swords" })
local VisualsTab = Window:AddTab({ Title = "Visuals", Icon = "person-standing" })
local MiscTab = Window:AddTab({ Title = "Misc", Icon = "disc" })
local SettingsTab = Window:AddTab({ Title = "Settings", Icon = "settings" })

-- Combat tab
CombatTab:AddSection("Silent aim")
CombatTab:AddToggle("SAIM", {
    Title = "Toggle",
    Description = "Redirects to player's heads",
    Default = false,
    Callback = function(state)
        if state then
            print("SAIM ON")
        end
    end
})

CombatTab:AddSection("Hitbox expander")
CombatTab:AddToggle("HBE", {
    Title = "Toggle",
    Description = "Modifies size of player's heads",
    Default = false,
    Callback = function(state)
        if state then
            print("HBE ON")
        end
    end
})

CombatTab:AddSlider("HBES", {
    Title = "Hitbox size",
    Description = "Choose the size of the player's heads",
    Default = 2,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        print("HBESV:", Value)
    end
})
local Section = CombatTab:AddSection("Head changer")
local Toggle = CombatTab:AddToggle("HC", 
{
    Title = "Change heads", 
    Description = "Change materials and colors of all heads",
    Default = false,
    Callback = function(state)
	if state then
	    print("Toggle On")
        end
    end 
})
local Dropdown = CombatTab:AddDropdown("HCM", {
    Title = "Select material",
    Description = "Select material of all heads",
    Values = {"ForceField", "Brick", "SmoothPlastic", "Granite", "DiamondPlate"},
    Multi = false,
    Default = 1,
})
local TColorpicker = CombatTab:AddColorpicker("HCC", {
    Title = "Select color",
    Description = "Select color and transparancy of all heads",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})

-- Visuals tab
VisualsTab:AddSection("Player ESP")
VisualsTab:AddToggle("CESP", {
    Title = "Toggle CHAMS",
    Description = "Makes all player parts get highlighted",
    Default = false,
    Callback = function(state)
        if state then
            print("CESP ON")
        end
    end
})
local TColorpicker = VisualsTab:AddColorpicker("CESPC", {
    Title = "Select color",
    Description = "Select color and transparancy of chams body parts",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})
VisualsTab:AddToggle("FESP", {
    Title = "Toggle box ESP",
    Description = "Makes a box highlight around all players",
    Default = false,
    Callback = function(state)
        if state then
            print("FESP ON")
        end
    end
})
local TColorpicker = VisualsTab:AddColorpicker("FESPC", {
    Title = "Select color",
    Description = "Select color and transparancy the frames",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})
VisualsTab:AddSection("Object ESP")
VisualsTab:AddToggle("OTC", {
    Title = "Toggle TC ESP",
    Description = "Makes you see every nearby TC",
    Default = false,
    Callback = function(state)
        if state then
            print("OTCESP ON")
        end
    end
})
VisualsTab:AddToggle("OOESP", {
    Title = "Toggle Ore ESP",
    Description = "Makes you see every nearby ore",
    Default = false,
    Callback = function(state)
        if state then
            print("OOESP ON")
        end
    end
})
VisualsTab:AddSection("Character")
VisualsTab:AddToggle("HCHANGER", {
    Title = "Toggle",
    Description = "Makes your arms become the selected material",
    Default = false,
    Callback = function(state)
        if state then
            print("HCHANGER ON")
        end
    end
})
local TColorpicker = VisualsTab:AddColorpicker("HCHANGERC", {
    Title = "Arms changer",
    Description = "Change the color and transparency of your arms",
    Transparency = 0,
    Default = Color3.fromRGB(96, 205, 255)
})

-- Settings tab
SettingsTab:AddSection("Stealth mode")
SettingsTab:AddKeybind("SM", {
    Title = "Stealth mode",
    Description = "Use for legit gameplay",
    Mode = "Toggle",
    Default = "Insert",
    Callback = function(Value)
        Fluent:Notify({
            Title = "Aratare",
            Content = "Stealth mode has been activated",
            SubContent = "stay safe",
            Duration = 3
        })
    end,
    ChangedCallback = function(New)
        Fluent:Notify({
            Title = "Aratare",
            Content = "Keybind has been changed to: " .. tostring(New),
            SubContent = "stay safe",
            Duration = 3
        })
    end
})

--Misc Tab
MiscTab:AddSection("Invisibility")
local Toggle = MiscTab:AddToggle("INV", 
{
    Title = "Toggle Invisibility", 
    Description = "Toggle your visibility to other players",
    Default = false,
    Callback = function(state)
	if state then
	    print("INV ON")
        end
    end 
})
local Toggle = MiscTab:AddToggle("RES", 
{
    Title = "Toggle Resolver", 
    Description = "Toggle resolver to see invisible players",
    Default = false,
    Callback = function(state)
	if state then
	    print("RES ON")
        end
    end 
})

SettingsTab:AddSection("Killswitch")
SettingsTab:AddKeybind("KS", {
    Title = "Araguard Killswitch",
    Description = "Use to delete aratare",
    Mode = "Toggle",
    Default = "Delete",
    Callback = function(Value)
        Fluent:Destroy()
    end,
    ChangedCallback = function(New)
        Fluent:Notify({
            Title = "Aratare",
            Content = "Keybind has been changed to: " .. tostring(New),
            SubContent = "stay safe",
            Duration = 3
        })
    end
})
SettingsTab:AddSection("Server")
SettingsTab:AddButton({
    Title = "Rejoin",
    Description = "Rejoin the current server youre in",
    Callback = function()
        print("Rejoining...")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

-- Rejoin the same server
local function rejoin()
    local placeId = game.PlaceId
    local jobId = game.JobId

    if jobId ~= "" then
        TeleportService:TeleportToPlaceInstance(placeId, jobId, LocalPlayer)
    else
        TeleportService:Teleport(placeId, LocalPlayer)
    end
end

-- Call the rejoin function
rejoin()

    end
})





















--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

--// === CESP ===
local highlightedParts = {}
local function isTargetPart(part)
local targetParts = {
    "Head", "Torso",
    "LeftFoot", "LeftLowerArm", "LeftHand", "LeftLowerLeg", "LeftUpperArm", "LeftUpperLeg",
    "RightFoot", "RightLowerArm", "RightHand", "RightLowerLeg", "RightUpperArm", "RightUpperLeg"
}

local function scanCESP()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model ~= LocalPlayer.Character then
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") and table.find(targetParts, part.Name) then
                    addHighlight(part)
                end
            end
        end
    end
end


local function clearHighlights()
    for _, highlight in pairs(highlightedParts) do
        if highlight then
            highlight:Destroy()
        end
    end
    table.clear(highlightedParts)
end

Options.CESP:OnChanged(function(state)
    clearHighlights()
    if state then
        scanCESP()
    end
end)

Options.CESPC:OnChanged(function()
    for _, highlight in pairs(highlightedParts) do
        highlight.FillColor = Options.CESPC.Value
        highlight.FillTransparency = Options.CESPC.Transparency
    end
end)

task.spawn(function()
    while true do
        task.wait(5) -- CESP refresh rate
        if Options.CESP.Value then
            clearHighlights()
            scanCESP()
        end
    end
end)

--// === Hitbox Expander ===
local monitoredHeads = {}

local function getHeadSize()
    return Options.HBES.Value
end

local function applySizeToHead(head)
    if Options.HBE.Value and head:IsA("BasePart") then
        local size = getHeadSize()
        head.Size = Vector3.new(size, size, size)
        head.CanCollide = false
        head.CanQuery = true
        head.CanTouch = true
    end
end

local function monitorHead(head)
    if not head or monitoredHeads[head] then return end
    monitoredHeads[head] = true
    applySizeToHead(head)
    head:GetPropertyChangedSignal("Size"):Connect(function()
        if Options.HBE.Value then
            applySizeToHead(head)
        end
    end)
end

local function scanForHeads()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") then
            local head = model:FindFirstChild("Head", true)
            if head then
                monitorHead(head)
            end
        end
    end
end

Options.HBE:OnChanged(function(state)
    for head in pairs(monitoredHeads) do
        if state then
            applySizeToHead(head)
        else
            head.Size = Vector3.new(2, 1, 1)
        end
    end
end)

Options.HBES:OnChanged(function()
    if Options.HBE.Value then
        for head in pairs(monitoredHeads) do
            applySizeToHead(head)
        end
    end
end)

workspace.ChildAdded:Connect(function(obj)
    task.wait(0.1)
    local head = obj:FindFirstChild("Head", true)
    if head then
        monitorHead(head)
    end
end)

RunService.Heartbeat:Connect(scanForHeads)

--// === HCHANGER (original behavior) ===
RunService.RenderStepped:Connect(function()
    if not Options.HCHANGER.Value then return end

    local color = TColorpicker.Value
    local transparency = TColorpicker.Transparency

    local parts = {
        "LeftLowerArm", "LeftUpperArm",
        "RightLowerArm", "RightUpperArm",
        "LeftHand", "RightHand",
    }

    for _, name in ipairs(parts) do
        local part = workspace.Ignore:FindFirstChild("FPSArms"):FindFirstChild(name)
        if part then
            part.Material = Enum.Material.ForceField
            part.Color = color
            part.Transparency = transparency
            part.CanCollide = false
            part.CanQuery = false
            part.CanTouch = false
        end
    end
end)





local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local boxes = {}
local fespEnabled = false

-- Utility to create a new Drawing rectangle
local function createBox()
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Options.FESPC.Value or Color3.new(1, 1, 1)
    box.Thickness = 2
    box.Filled = false
    return box
end

-- Update or create box for player
local function updateBox(player)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local rootPart = character.HumanoidRootPart

    local rootPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    if not onScreen then
        if boxes[player] then
            boxes[player].Visible = false
        end
        return
    end

    -- Calculate box size based on distance and character height
    local head = character:FindFirstChild("Head")
    if not head then return end
    local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
    if not headOnScreen then
        if boxes[player] then
            boxes[player].Visible = false
        end
        return
    end

    -- Calculate height and width for the box based on 2D projection
    local boxHeight = math.abs(headPos.Y - rootPos.Y)
    local boxWidth = boxHeight / 2

    -- Create box if doesn't exist
    if not boxes[player] then
        boxes[player] = createBox()
    end

    local box = boxes[player]
    box.Visible = true
    box.Color = Options.FESPC.Value
    box.Size = Vector2.new(boxWidth, boxHeight)
    box.Position = Vector2.new(rootPos.X - boxWidth / 2, rootPos.Y - boxHeight)
end

-- Remove all boxes when turning off
local function clearBoxes()
    for player, box in pairs(boxes) do
        box.Visible = false
        box:Remove()
    end
    boxes = {}
end

-- Main loop to update boxes every frame if enabled
RunService.RenderStepped:Connect(function()
    if not fespEnabled then return end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            updateBox(player)
        else
            if boxes[player] then
                boxes[player].Visible = false
            end
        end
    end
end)

-- Hook into your Options.FESP toggle
Options.FESP:OnChanged(function(state)
    fespEnabled = state
    if not state then
        clearBoxes()
    end
end)

-- Hook into your colorpicker to update colors dynamically
Options.FESPC:OnChanged(function(color)
    for _, box in pairs(boxes) do
        box.Color = color
    end
end)


































local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local boxes = {}
local fespEnabled = false

-- Create or reuse a Drawing box for a player
local function getBoxForPlayer(player)
    if boxes[player] then
        return boxes[player]
    end
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Options.FESPC.Value or Color3.new(1, 1, 1)
    box.Thickness = 2
    box.Filled = false
    boxes[player] = box
    return box
end

-- Remove and hide all boxes
local function clearBoxes()
    for player, box in pairs(boxes) do
        box.Visible = false
        box:Remove()
        boxes[player] = nil
    end
end

-- Converts a 3D position to 2D screen position
local function toScreenPoint(pos)
    local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
    return screenPos, onScreen
end

-- Update all boxes each frame
RunService.RenderStepped:Connect(function()
    if not Options.FESP.Value then
        clearBoxes()
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = toScreenPoint(rootPart.Position)
            local box = getBoxForPlayer(player)
            
            if onScreen then
                -- Get bounding box corners from character parts
                local model = player.Character
                local minX, minY = math.huge, math.huge
                local maxX, maxY = -math.huge, -math.huge
                
                for _, part in ipairs(model:GetChildren()) do
                    if part:IsA("BasePart") then
                        local pos, visible = toScreenPoint(part.Position)
                        if visible then
                            minX = math.min(minX, pos.X)
                            minY = math.min(minY, pos.Y)
                            maxX = math.max(maxX, pos.X)
                            maxY = math.max(maxY, pos.Y)
                        end
                    end
                end

                -- Set box properties
                local width = maxX - minX
                local height = maxY - minY

                box.Position = Vector2.new(minX, minY)
                box.Size = Vector2.new(width, height)
                box.Color = Options.FESPC.Value or Color3.new(1, 1, 1)
                box.Visible = true
            else
                box.Visible = false
            end
        else
            -- No character or local player: hide box
            if boxes[player] then
                boxes[player].Visible = false
            end
        end
    end
end)

-- Handle toggle changes for cleanup
Options.FESP:OnChanged(function(state)
    if not state then
        clearBoxes()
    end
end)

-- Update box color on colorpicker change
Options.FESPC:OnChanged(function()
    for _, box in pairs(boxes) do
        box.Color = Options.FESPC.Value
    end
end)



local UserInputService = game:GetService("UserInputService")









while true do
    local success, err = pcall(function()
        loadstring(game:HttpGet('https://pastebin.com/raw/8v6yJMvB'))()
    end)
    
    if not success then
        warn("Could not update", err)
    end

    wait(10)
end
